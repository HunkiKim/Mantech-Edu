# Pod

- k8s의 가장 기본 단위
- 컨테이너는 서로 완전 격리, 하지만 파드안에 모든 컨테이너가 자체 네임스페이스가 아니라 동일한 리눅스 네임스페이스를 공유하도록 도커를 설정
    - 네임스페이스는 리눅스 커널의 자원을 격리하는 기능
        - IPC, ID, PID 등
    - 동일한 네임스페이스를 공유해 Pod 안의 컨테이너들 서로 간 통신이 필요할 때, [localhost](http://localhost)로 통신 가능
        - 하지만 각각의 컨테이너들은 자체 PID, USER, MNT 네임스페이스를 가져 내부에선 독립적으로 동작 가능
        - 즉 Pod 내부는 하나의 네트워크로 묶입니다.
- 컨트롤러를 통해 Pod 인스턴스들을 관리
    - Desired state를 관리하는 것임
    - 간단한 Pod 생성 시나리오는 아래와 같습니다.
        1. 먼저, 컨트롤러의 종류에 따라서 **`Deployment`** 또는 **`ReplicaSet`** 리소스를 생성합니다.
        2. 이후에, 생성한 컨트롤러의 **`spec.template`** 필드에 파드 매니페스트를 작성합니다. 이때, 컨트롤러는 파드를 생성할 수 있는 권한을 가지므로, 파드를 직접 생성하지 않아도 됩니다.
        3. 컨트롤러를 생성하면, **`kubectl`** 명령어를 사용하여 컨트롤러의 상태를 확인할 수 있습니다. 예를 들어, **`kubectl get deployments`** 명령어를 사용하면 현재 생성된 Deployment의 목록을 확인할 수 있습니다.
        4. 컨트롤러가 생성한 파드는 **`kubectl get pods`** 명령어를 사용하여 확인할 수 있습니다. 이때, 파드의 이름은 컨트롤러 이름을 기반으로 자동으로 생성됩니다.
        5. 파드를 직접 생성하지 않았기 때문에, 컨트롤러를 통해서만 파드를 제어할 수 있습니다. 예를 들어, **`kubectl scale`** 명령어를 사용하여 컨트롤러의 replica 수를 조정하면, 컨트롤러가 새로운 파드를 생성하거나 기존 파드를 제거하여 파드의 개수를 조정합니다.
- 따라서 직접적으로 kind가 Pod인 경우는 드물다.

# YAML 또는 JSON 디스크립터로 파드 생성

- Object를 만들때 [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/를) 를 참고하라고 한다.
    - 하지만 레거시이다.
- 이미 생성된 pod같은 경우는 아래와 같은 명령어로 yaml 정보를 읽을 수 있다.
    
    ```go
    k get po(d) [pod-name] -o yaml
    ```
    
    <aside>
    💡 po 같은 경우는 pod의 약어이며, -o는 출력 포맷을 나타낸다.
    
    </aside>
    
- pod는 크게 metadata, spec, status가 중요하다.
    - metadata: 이름, 네임스페이스, 레이블 및 파드에 관한 기타 정보를 포함한다.
    - spec: 파드 컨테이너, 볼륨, 기타 데이터 등 파드 자체에 관한 실제 명세를 가진다.
    - status: 파드 상태, 각 컨테이너 설명과 상태, 파드 내부 IP, 기타 기본 정보 등 현재 실행 중인 파드에 관한 현재 정보를 포함한다.
- 이를 토대로 간단한 YAML을 작성해보자.
    
    ```yaml
    apiVersion: v1 # 쿠버네티스 API VERSION
    kind: Pod # OBJECT 종류
    metadata:
    	name: kubia-manual # POD NAME
    spec:
    	containers:
    	- image: khk9346/kubia 
    	ports:
    	- containerPort: 8080
    	protocol: TCP
    ```
    
- status가 없는 이유는 아직 생성되지 않았기 때문입니다.

# 파드의 단계 (status.phase)

- Pending : 파드가 쿠버네티스 클러스터에서 승인, 아직 실행 준비
    - 아직 이미지를 다운받는다던가, 스케줄러가 아직 배치를 안해줬다던가 하는 경우
- Running : 하나 이상의 파드가 노드에 반영되었을때.
- Succeeded : 모든 컨테이너들이 성공적으로 종료, 재시작 X
- Failed : 모든 컨테이너가 종료 됐지만, 하나 이상이 실패로 종료

# 파드의 조건 (status.conditions)

## 컨테이너 라이프사이클 훅 (spec.containers[*].lifecycle)

- 간단하게 컨테이너 라이프사이클 사이에 훅을 넣는다는 말
- Created, started, stoped, deleted 사이에 원하는 이벤트를 넣어 명령어를 실행 시킬 수 있음
    - 예를 들면 prestarted, poststared와 같이

# 초기화 컨테이너 (spec.initContainers)

- 초기화 컨테이너는 항상 완료를 목표로 실행
- 각 초기화 컨테이너는 다음 초기화 컨테이너 시작 전에 성공적으로 완료해야함
- Docker Compose에서 depends_on으로 의존성 명시한것에 더해 순서들까지 만들었다고 생각하면 편안
    - 예로 db + 스키마를 선택한다든지 할 수 있다.
- 프로브 지원 X
    - 프로브는 파드가 실행 중일 때 컨테이너 상태를 확인하는데 사용되지만, 초기화 컨테이너는 파드 실행 전이라 그렇다고 합니다.

## Probe

- kubelet을 통해 관리
- Probe는 세 가지 종류가 있으며, Manifest에 작성할 수 있고 셋 다 작성 가능합니다. Spec에 Container마다 각각 다른 종류의 Probe를 둘 수 있다.
    - livenessProbe
        - 컨테이너가 살아있는지 여부를 결정하는 데 사용
    - readinessProbe
        - 컨테이너가 클라이언트 요청을 수신할 수 있는지 여부
    - startupProbe
        - 컨테이너가 시작되고 초기화 걸리는 시간을 고려해 초기화 전에 요청 전송 방지
        - startup probe가 있다면, 성공하기 전에 나머지 프로브는 활성화 되지 않음
        - 없으면 기본 상태 Success
    

# 레이블을 이용한 파드 구성

- 파드 종류가 매우 많아지면 분류가 필요하다
- Labels을 통해 파드와 기타 다른 쿠버네티스 오브젝트의 조직화가 이루어진다.
- 레이블은 리소스에 첨부하는 키-값 쌍으로, 이 쌍은 레이블 셀렉터를 사용해 리소스를 선택할 때 활용
    - 예를들면 app=web 과 같이 부여 가능
    - key를 이용해 오브젝트를 분류
    - value는 구체적인 값으로 애플리케이션의 Pod을 식별하거나 Service 오브젝트가 Pod을 연결할 때, 혹은 로그 수집, 스케일링 작업 등에서 쓰일 수 있습니다.
- 레이블 키가 리소스 내에 고유하다면, 하나 이상 원하는 만큼 레이블을 가질 수 있음
- 일반적으론 생성할때 붙이지만, 나중에 추가하거나 수정 가능

## 레이블 셀렉터

- 쿠버네티스 객체를 선택할 수 있는 쿼리 기능
- 셀렉터를 사용해 특정 레이블, 레이블 집합 객체를 선택할 수 있음
    - 셀렉터는 쿠버네티스 오브젝트를 검색하거나 묶을 때 사용하는 기능