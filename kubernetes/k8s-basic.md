# Kubernetes 넓게 바라보기

- 컨테이너화 된 애플리케이션들을 쉽게 관리하고 운영할 수 있게 해주는 소프트웨어 시스템
- 개발자가 매니페스트(앱 디스크립터)를 마스터에 게시하면, 쿠버네티스가 워커 노드 클러스터에 배포
    - 개발자는 이 앱이 어떤 노드에 배포되는지는 중요하지 않다. 이는 설정값에 맞춰 자동적으로 된다.
- 쿠버네티스는 OS와 비슷한 구조로 형성이 된다.

# 쿠버네티스 클러스터 아키텍처 이해

- 여러 노드들이 있지만 크게 마스터 노드와 워커 노드 두 가지 유형으로 나뉜다.
    - 마스터노드는 클러스터의 전체 쿠버네티스 시스템을 관리하고, 쿠버네티스 컨트롤 플레인을 실행한다
    - 워커노드는 실제 애플리케이션을 실행한다

# 마스터 노드

## 컨트롤 플레인

- 클러스터를 제어하고 작동시킨다.
- 하나 이상의 마스터 노드에서 실행.
    - 한 마스터 노드당 하나의 컨트롤 플레인이 실행되지만 고가용성을 위해 마스터 노드를 복제해 두고, 이에 맞춰 컨트롤 플레인도 같이 생성이 되기 때문에 하나 이상이라고 명시
    - 복제된 마스터 노드는 보통 활성화되지 않은 상태에서 필요할때 사용
- 구성요소론 다음과 같다.
    - API Server
        - 사실상 중앙에서 요청을 처리하는 역할
        - Kubernetes Cluster의 어느 요청이든 API Server를 통해 이뤄진다.
        - 시스템 컴포넌트들은 오직 API 서버와 통신하며, 모든 오브젝트가 사실상 API Server에서 이루어진다고 봐야합니다.
        - 모든 요청이 있기 때문에 Authentication, Authorization, Admission Control 또한 API Server에서 이뤄집니다.
            - 인증, 인가는 말 그대로 사용자 인증, 권한 확인의 과정이며 Admission Control은 Validation, 값 자동 생성, 기본값 추가와 같은 작업을 합니다.
    - Scheduler
        - Manifest의 리소스와 kubelet을 통해 어떤 노드로 파드를 배치할지 정하는 역할을 합니다.
        - 즉 애플리케이션을 실제로 배포합니다.
        - 최적의 노드 선택에는 두 가지 방법이 있습니다.
            - 필터링
            - 스코어링
    - etcd (distributed key-value store)
        - 분산 key-value 저장소로, k8s에선 사실상 모든 정보들이 저장되는 곳입니다.
        - 즉 클러스터의 모든 정보를 가지고 있는 곳입니다.
        - RAFT 알고리즘을 사용한다고 합니다.
            - 리더,팔로워,후보자 세 가지 역할로 노드를 구성하고 리더 선출, 로그 복제 등의 과정을 통해 분산시스템의 일관성을 유지한다고 하는데 자세하겐 모르겠습니다
        - API를 통해 쿠버네티스에서 사용되는 모든 리소스들을 저장합니다.
    - Controller Manager
        - 컨트롤러 오브젝트들이 존재합니다.
            - Controller Manager들이 관리하는 컨트롤러 오브젝트들은 Desired State를 가집니다. spec field가 바로 그것이며, 이 상태를 기반으로 모니터링하고, 현재 상태가 Desired State와 일치하지 않으면 최대한 가깝게 만듭니다.
            - Deployment, ReplicaSet, DamemonSet, Job 등의 리소스 타입을 관리합니다.

# 워커 노드

- 워커 노드는 컨테이너화된 애플리케이션을 실행하는 시스템입니다.
- 애플리케이션을 실행하고 모니터링합니다.
- 또한 다음 구성요소에 의해 애플리케이션에 서비스를 제공합니다.
    - 컨테이너 런타임
    - kubelet 컴포넌트
    - kube-proxy 컴포넌트

## Kubelet

- 워커 노드에 있는 컴포넌트이며, 클러스터의 각 노드마다 실행되는 에이전트입니다.
    - 여기서 에이전트는 노드가 다른 시스템, 네트워크와 상호 작용하는 작업을 수행해주는 소프트웨어 프로그램이라는 뜻입니다.
    - 즉 다른 노드나 API서버와 상호작용하는 컴포넌트입니다.
- 파드에서 컨테이너가 확실하게 동작하도록 관리
    - Pod의 목록을 주기적으로 가져와 Pod안에 있는 컨테이너들을 확인
    - 각 컨테이너 상태를 주기적으로 감시, 필요하면 컨테이너를 다시 시작하거나 중지
    - API 서버로 해당 정보도 저장
- 네트워크와 스토리지 또한 구성하고 관리
- kublet도 liveness probe를 실행하는 컴포넌트, 다운이 되면 Pod의 상태를 감시 못해 클러스터 전체의 안정성에 영향을 미친다.

## Kube-proxy

- kube-proxy는 노드의 네트워크 규칙을 관리하며, 이 규칙을 통해 바깥에서 파드로 네트워크 통신이 가능
- 컨트롤 플레인의 서비스 및 엔드포인트 오브젝트의 추가와 제거를 감시
- usernamespace, iptables, IPVS를 통해 외부에서 Pod을 찾을 수 있습니다.
    - 각자 다른 특징과 장단점이 있습니다.
    - 보안적인 이유로 usernamespace 방식은 잘 사용되지 않습니다.
    - iptables 방식은 kube-proxy가 iptables를 사용해 가상 ip주소를 물리적인 pod ip 주소로 매핑하는 방식. 가장 많이 사용되며 빠르게 구성 가능
    - IPVS 방식은 Linux 커널에서 제공하는 IPVS를 사용해 로드밸런싱을 수행하는 방식. 더 빠르고 성능 좋고, 다양한 로드밸런싱 알고리즘이 있어 성능이 중요하면 더 적합
- 즉 순서는 이렇습니다.
    - 서비스의 가상 IP 주소로 요청
    - 그러면 API 서버로 요청 전달
    - API 서버는 etcd에 저장된 클러스터 정보와 비교해 해당 서비스와 매칭되는 Pod IP 주소를 찾음
    - 이후 Pod IP 주소를 클라이언트에게 반환
        - 동일한 레이블 셀렉터를 가진 같은 종류의 Pod들의 IP주소
    - 몰론 Pod는 클러스터 내부 네트워크에서 격리되어 있기 때문에 직접 접근은 불가능
    - kube-proxy가 제공하는 로드 밸런싱 기능을 사용해 Pod ip 주소를 물리적인 노드 ip 주소로 매핑하고, 이를 통해 pod에 접근
        - 여기서 kube-proxy가 제공하는 로드 밸런싱 기능이 iptables와 IPVC 입니다.
            - iptables 룰을 적용해, 서비스의 ClusterIP 주소로 들어오는 트래픽을 Pod으로 라우팅
                - ClusterIP주소는 쿠버네티스 클러스터 내에서 사용되는 가상 IP 주소, Pod들을 논리적으로 그루핑
                - 클라이언트가 ClusterIP주소로 요청을 하면 kube-proxy가 실제 물리적 PodIP를 반환하게 되고 이를 통해 Pod에 직접 접근 가능
            - IPVC를 통해 로드밸런싱 수행
    - 위의 iptables나 ipvc는 필터링 계층이라고도 부른다.

# 쿠버네티스 특징

- 서비스 디스커버리
- 로드밸런싱
- 스토리지 오케스트레이션
- 자동화된 롤아웃,롤백
- 자동화된 빈 패킹
- Self-Healing
- Auto-Scailing
- Job
- Secret과 구성 관리