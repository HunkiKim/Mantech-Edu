# 어노테이션

- 파드 및 다른 오브젝트들은 레이블 외에 어노테이션을 가질 수 있다.
- 키-값 쌍으로 레이블과 비슷하지만 식별정보가 없고, 레이블보다 더 큰 값을 기록할 때 많이쓴다.
    - 자동으로 추가되는 경우도 있고, 수동으로도 가능하다
- 쿠버네티스 새로운 기능 추가할 때 주로 쓴다고 한다.
    - Javadocs 같은 느낌인것같다.
    - 하지만 일반적으론 CRD(Custom Resource Definition)을 주로 쓴다고 한다.
- 주로 사용되는 경우는 파드나 다른 API 오브젝트에 설명을 쓸 때 사용해, 개별 오브젝트 관한 정보를 신속하게 찾을 수 있다고 한다.
    - 예를 들어 클러스터 내에 오브젝트를 만든 사람 이름을 어노테이션으로 지정하면, 협업이 용이해진다.

## 오브젝트의 어노테이션 조회

- 2장에서 파드를 생성할 때 쿠버네티스가 자동으로 추가한 어노테이션을 예로 살펴보자

```yaml
metadata:
	annotations:
		kubernetes: 
			kubernetes.io/created-by: |
				{"kind" : "SerializedReference", "apiVersion":"v1",
				"reference":{"kind":"Replicationcontroller", "namespace":"default" ..... }}
```

- 위를 보면 [Kubernetes.io/created-by](http://Kubernetes.io/created-by) 어노테이션이 오브젝트를 사용할 때 사용한 JSON 데이터를 갖고 있는 것을 볼 수 있다. 레이블엔 애매하지만 어노테이션은 256KB까지 넣을 수 있다.

## 어노테이션 추가 및 수정

레이블을 만들 때와 같은 방법으로 파드를 생성할 때 어노테이션을 추가할 수 있다.

```yaml
kubectl annotate pod kubia-manual mycompany.com/someannotation="foo bar"
```

위와 같이 annotate 명령어를 쓰면 된다.

# 네임스페이스를 사용한 리소스 그룹화

- 클러스터가 하나의 OS처럼 사용된다면, 사용자마다 오브젝트를 분리하여 사용할 수 있는 공간 또한 존재 할 수 있다.
    - Linux의 사용자 시스템과 비슷한 느낌이다.
- 레이블을 사용하면 여러 오브젝트들이 중복적으로 되지만, 네임 스페이스는 그렇지 않다.
    - 클러스터 내의 공간을 따로 쓰는 느낌이라고 생각하면 된다.
- 서로 격리되어 있지만, 근본적으론 같은 클러스터 내에 있기 떄문에 네트워크 정책을 사용해 트래픽 제어, 파드 연결등을 할 순 있다.
- namespace 생성도 마찬가지로 manifest를 작성해 제출하면 된다고 한다.
    - namespace도 클러스터 내의 오브젝트이기 때문이다.
    - 하지만 번거로우면 아래처럼 작성 가능
    
    ```yaml
    k create namespace custom-namespace
    ```
    

# 파드 중지와 제거

- 파드 이름을 통해 파드를 삭제하면 모든 컨테이너를 중지한다.
    - SIGREM → 종료안되면 SIGKILL
- 레이블 셀렉터를 이용해 파드 삭제 가능
    - 해당 레이블의 파드 모두 제거
- 네임스페이스를 통한 파드 삭제
    - 네임스페이스 제거 → 안 파드도 같이 제거
- 네임스페이스 유지하면서 네임스페이스 안의 파드만 제거할 수 있다.
    - 삭제하고싶은 네임스페이스 Context로 변경
    - k delete po —all을 사용해 내부 파드 모두 삭제
        - 하지만 컨트롤러 있으면 desired state때문에 삭제가 안된다.
    - k delete all —all을 하면 네임스페이스 내의 모든 리소스들을 삭제한다.
    

## Pod 안정적으로 유지하기

- 컨트롤러 없이 Pod만 생성해서 관리하면, Docker랑 다를게 없다.
- Controller를 통해 자동으로 생성, 감독, 관리 등을 할 수 있다.
    - k8s의 주요 이점 중 하나는 원하는 상태로 클러스터에서 컨테이너를 실행상태를 유지해준다는 것이다.
- 파드내의 컨테이너가 죽으면 kubelet이 확인하고 컨테이너를 실행하도록 한다.
    - 특별한 작업 없이 실행만 해도 해당 기능은 자동 치유를 한다.
    - 하지만 Application이 메모리가 가득차 오류를 계속 발생시키지만, JVM이 켜져있어 컨테이너가 꺼져있지 않으면 이는 확인할 방법이 없다.
    - 이는 내부기능을 의존하지말고, 외부기능을 의존해야 한다.
- 외부기능엔 프로브가 있다.
    - 라이브니스 프로브 같은 경우는 GET,TCP 소켓, Exec 프로브가 있으면 manifest의 spec에 작성 가능하다.
    
    ```bash
    spec:
    	liveniessProbe:
    	httpGet:
    		path: /
    		port: 8080
    ```
    
    - pod의 Restart가 있을때 describe pod를 통해 재시작 정보를 확인 가능하다.
        - 여기서 137은 외부에서 종료했음을 의미하니 중요하다
        - health를 만들어 내부 기능을 확인하는 api를 농해 get요청하는 예시도 있다.
    - 자주 실행하니 가볍게 만들고, 재시도 루프를 만들어 무한재시작을 하지 않도록 하자.

# ReplicationController

- 현재는 잘 쓰지 않으며, Deployment를 주로 쓴다
- ReplicationController는 레이블 셀렉터를 통해 파드를 찾고, 현재 파드 수와 의도된 파드수가 다르면 추가 혹은 삭제를 하여 파드 실행을 보장해준다.
- 이름 그대로 템플릿의 복제본을 통해 파드를 관리한다.
- 템플릿은 변경이 가능한데, 다른 컨트롤러 학습시 자세히 하도록 하자
- 컨트롤러 삭제시 파드도 같이 삭제된다.
    - cascade==false 명령어와 함께 컨트롤러를 삭제하면 파드를 유지시킨채 컨트롤러를 삭제 가능하다.
        - 이는 다른 컨트롤러로 전환시 유용하다.